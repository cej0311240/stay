{"ast":null,"code":"// supabaseClient 불러와서 연결해서 사용\nimport supabase from\"./supabaseClient\";/**\n * ✅ 현황판 전체 조회 (APT + STORE 한 번에)\n * 프론트에서 zone으로 나눠서 보여주면 됨\n */export const fetchParkingSpots=async()=>{const{data,error}=await supabase.from(\"parking_spots\").select(\"spot_id, zone, is_occupied, occupant_car, updated_at\").order(\"zone\",{ascending:true})// APT / STORE 정렬\n.order(\"spot_id\",{ascending:true});// A-1, A-2 ... 순서\nif(error)throw error;return data;// [{spot_id, zone, is_occupied, occupant_car, updated_at}, ...]\n};/**\n * ✅ 실시간 주차 현황(공용)\n * - total: 총 주차공간\n * - occupied: 주차중(주차대수)\n * - empty: 빈 공간\n */export const fetchParkingStatusSummary=async()=>{const{data,error}=await supabase.from(\"parking_spots\").select(\"is_occupied\");if(error)throw error;const total=data.length;const occupied=data.filter(row=>row.is_occupied===true).length;const empty=total-occupied;return{total,occupied,empty};};//추가로 입력한 부분\n//-----------------------------------------------------------------------//\n//control 페이지에 필요한 api정보\n//-----------------------------------------------------------------------//\n//등록차량 확인\nexport const registConfirm=async carNum=>{//등록된 차량인지 체크 및 상태값 전달\n//1.입주민인지 - 상가주인인지 profiles 테이블에서 확인\n//2.방문예약차량 확인\nlet car_Type=\"VISIT\";let parking_zone=\"STORE\";const{data:registCheck,error:regist_error}=await supabase.from(\"profiles\").select(\"user_type\").or(\"car_num.eq.\".concat(carNum,\",add_car.eq.\").concat(carNum))// 등록차량 또는 추가등록차량\n.maybeSingle();if(regist_error){throw new Error(\"등록된 차량 확인 시 오류 발생\"+regist_error.message);}const registstate=registCheck?true:false;if(!registstate){//입주민이 아니면\nconst{data:reservationCheck,error:reservation_error}=await supabase.from(\"parking_reservations\")//방문예약차량인지확인\n.select(\"visit_type\").neq(\"profile_id\",2).eq(\"car_num\",carNum).maybeSingle();const reservationstate=reservationCheck?true:false;if(reservation_error){throw new Error(\"등록된 차량 확인 시 오류 발생\"+reservation_error.message);}if(reservationstate){//입주민이 아니고 방문예약차량이 맞으면\ncar_Type=reservationCheck.visit_type;parking_zone=\"APT\";}}else{//입주민이면\ncar_Type=registCheck.user_type;parking_zone=\"APT\";// if(registCheck.user_type===\"STORE\"){\n//   parking_zone=\"STORE\";\n// }else{\n//   parking_zone=\"APT\";\n// }\n}return{parking_zone,car_Type};};//입차처리\nexport const enterParking=async(carNum,parking_zone)=>{let statMsg=\"\";//동일차량제어\nconst{data:duplication}=await supabase.from(\"parking_spots\").select(\"spot_id\").eq(\"occupant_car\",carNum).maybeSingle();const duplicationstat=duplication?true:false;if(duplicationstat){statMsg=duplication.spot_id+\"에 이미 주차되어있는 차량입니다\";throw new Error(duplication.spot_id+\"에 이미 주차되어있는 차량입니다\");}//빈자리를 찾기 : 주차 공간 확보 //등록된 차량이면 아파트에 빈자리를 확인 미등록된 차량이면 상가에 빈자리를 확인 //car_num = null 그리고 type이 일치\nconst{data:spots,error:spot_error}=await supabase.from(\"parking_spots\").select(\"spot_id\").eq(\"zone\",parking_zone).is(\"occupant_car\",null);// .order(\"spot_id\", { ascending: true })\n// .limit(1);\nif(!spots||spots.length<=0||spot_error){statMsg=\"주차공간이 없습니다.\";throw new Error(\"주차 공간이 없습니다\");}const targetID=spots[Math.floor(Math.random()*spots.length)].spot_id;// const targetID = spots[0].spot_id; \n//parking_spots 테이블에 저장 parking_spots테이블은 화면을 구성하는 테이블 입니다.\nconst{error:parking_spots_error}=await supabase.from(\"parking_spots\").update({occupant_car:carNum,is_occupied:true}).eq(\"spot_id\",targetID);if(parking_spots_error)throw new Error(parking_spots_error);//parking_reservations 테이블을 이용해서 정산기능 구현했습니다.\n//16번 아이디가 삭제되면 안됩니다.\nconst{error:parking_reservations_error}=await supabase.from(\"parking_reservations\").insert([{profile_id:2,car_num:carNum,visit_type:\"VISIT\",start_date:new Date().toISOString(),end_date:new Date().toISOString()}]);if(parking_reservations_error)throw new Error(parking_reservations_error.message);return{targetID,statMsg};};//출차 처리\nexport const exitParking=async carNum=>{//1. 차량찾기\nconst{data:spot}=await supabase.from(\"parking_spots\").select(\"*\").eq(\"occupant_car\",carNum).single();//한개만 가져와라\nif(!spot)throw new Error(\"주차장에 차가 없습니다\");const{data:reservations}=await supabase.from(\"parking_reservations\").select(\"*\").eq(\"car_num\",carNum).eq(\"profile_id\",2).single();//한개만 가져와라\nlet registerTime=null;if(spot.zone===\"APT\"){//이미 등록되어서 정산하지 않고 출차\nconsole.log(\"주차타입 :\"+spot.zone);registerTime=0;}else{//2. 주차한 차를 찾으면, 주차 시간을 계산하기\nconst nowTime=new Date();console.log(\"현재시간 :\"+nowTime);const entryTime=new Date(reservations.start_date);//DB String --> Object // 현재시간 - 입차시간\nconsole.log(\"입차시간 :\"+entryTime);const diff=nowTime.getTime()-entryTime.getTime();console.log(\"현재시간 - 입차시간 :\"+diff);//시간주차를 했는지. 1초 이상 1시간\n// registerTime = Math.round(diff / (1000 * 60 * 60 * 9));\nregisterTime=Math.round(diff/60000);console.log(\"최종시간 :\"+registerTime+\"분\");}return{registerTime:registerTime,spot_id:spot.spot_id,spot_type:spot.zone,need_settlement:reservations.need_settlement};};//출차 확정\nexport const confirmExit=async(spotId,carNum)=>{const{error:parking_spots}=await supabase.from(\"parking_spots\").update({occupant_car:null,updated_at:null,is_occupied:false}).eq(\"spot_id\",spotId);if(parking_spots)throw new Error(\"출차하지 못했습니다\");const{error:parking_reservations_error}=await supabase.from(\"parking_reservations\").delete().eq(\"car_num\",carNum).eq(\"profile_id\",2);if(parking_reservations_error)throw new Error(parking_reservations_error);};export const adjustment=async carNum=>{const{data:settlement,error}=await supabase.from(\"parking_reservations\").select(\"*\").eq(\"car_num\",carNum).eq(\"profile_id\",2).maybeSingle();if(error)throw error;return{settlement:settlement.need_settlement,sdata:settlement.start_date};};","map":{"version":3,"names":["supabase","fetchParkingSpots","data","error","from","select","order","ascending","fetchParkingStatusSummary","total","length","occupied","filter","row","is_occupied","empty","registConfirm","carNum","car_Type","parking_zone","registCheck","regist_error","or","concat","maybeSingle","Error","message","registstate","reservationCheck","reservation_error","neq","eq","reservationstate","visit_type","user_type","enterParking","statMsg","duplication","duplicationstat","spot_id","spots","spot_error","is","targetID","Math","floor","random","parking_spots_error","update","occupant_car","parking_reservations_error","insert","profile_id","car_num","start_date","Date","toISOString","end_date","exitParking","spot","single","reservations","registerTime","zone","console","log","nowTime","entryTime","diff","getTime","round","spot_type","need_settlement","confirmExit","spotId","parking_spots","updated_at","delete","adjustment","settlement","sdata"],"sources":["D:/포폴 사용/stay/src/api/parkingAPI.js"],"sourcesContent":["// supabaseClient 불러와서 연결해서 사용\nimport supabase from \"./supabaseClient\";\n\n/**\n * ✅ 현황판 전체 조회 (APT + STORE 한 번에)\n * 프론트에서 zone으로 나눠서 보여주면 됨\n */\nexport const fetchParkingSpots = async () => {\n  const { data, error } = await supabase\n    .from(\"parking_spots\")\n    .select(\"spot_id, zone, is_occupied, occupant_car, updated_at\")\n    .order(\"zone\", { ascending: true }) // APT / STORE 정렬\n    .order(\"spot_id\", { ascending: true }); // A-1, A-2 ... 순서\n  if (error) throw error;\n  return data; // [{spot_id, zone, is_occupied, occupant_car, updated_at}, ...]\n};\n\n/**\n * ✅ 실시간 주차 현황(공용)\n * - total: 총 주차공간\n * - occupied: 주차중(주차대수)\n * - empty: 빈 공간\n */\nexport const fetchParkingStatusSummary = async () => {\n  const { data, error } = await supabase\n    .from(\"parking_spots\")\n    .select(\"is_occupied\");\n  if (error) throw error;\n  const total = data.length;\n  const occupied = data.filter((row) => row.is_occupied === true).length;\n  const empty = total - occupied;\n  return { total, occupied, empty };\n};\n//추가로 입력한 부분\n\n\n\n\n\n\n//-----------------------------------------------------------------------//\n//control 페이지에 필요한 api정보\n//-----------------------------------------------------------------------//\n\n//등록차량 확인\nexport const registConfirm = async (carNum) => {\n  //등록된 차량인지 체크 및 상태값 전달\n  //1.입주민인지 - 상가주인인지 profiles 테이블에서 확인\n  //2.방문예약차량 확인\n  let car_Type=\"VISIT\";\n  let parking_zone=\"STORE\";\n  const { data: registCheck, error: regist_error } = await supabase\n    .from(\"profiles\")\n    .select(\"user_type\")\n    .or(`car_num.eq.${carNum},add_car.eq.${carNum}`) // 등록차량 또는 추가등록차량\n    .maybeSingle();\n  if (regist_error) {throw new Error(\"등록된 차량 확인 시 오류 발생\"+regist_error.message);}\n  \n  const registstate = registCheck ? true : false;\n  \n  if(!registstate){ //입주민이 아니면\n    const { data: reservationCheck, error: reservation_error } = await supabase\n      .from(\"parking_reservations\") //방문예약차량인지확인\n      .select(\"visit_type\")\n      .neq(\"profile_id\",2)\n      .eq(\"car_num\", carNum)\n      .maybeSingle(); \n    const reservationstate = reservationCheck ? true : false;\n\n    if (reservation_error) {throw new Error(\"등록된 차량 확인 시 오류 발생\"+reservation_error.message);} \n    \n    if(reservationstate){//입주민이 아니고 방문예약차량이 맞으면\n      car_Type = reservationCheck.visit_type;\n      parking_zone=\"APT\";\n    }\n  }else{//입주민이면\n    car_Type = registCheck.user_type;\n    parking_zone=\"APT\";\n    \n    // if(registCheck.user_type===\"STORE\"){\n    //   parking_zone=\"STORE\";\n    // }else{\n    //   parking_zone=\"APT\";\n    // }\n    \n  }\n  return { parking_zone, car_Type };\n\n}\n\n//입차처리\nexport const enterParking = async (carNum,parking_zone) => {\n\n  let statMsg = \"\";\n  //동일차량제어\n  const { data: duplication} = await supabase\n    .from(\"parking_spots\")\n    .select(\"spot_id\")\n    .eq(\"occupant_car\", carNum)\n    .maybeSingle();\nconst duplicationstat = duplication? true : false\nif(duplicationstat){\n  statMsg = duplication.spot_id+\"에 이미 주차되어있는 차량입니다\"\n  throw new Error(duplication.spot_id+\"에 이미 주차되어있는 차량입니다\");\n}\n\n\n  //빈자리를 찾기 : 주차 공간 확보 //등록된 차량이면 아파트에 빈자리를 확인 미등록된 차량이면 상가에 빈자리를 확인 //car_num = null 그리고 type이 일치\n  const { data: spots, error: spot_error } = await supabase\n    .from(\"parking_spots\")\n    .select(\"spot_id\")\n    .eq(\"zone\", parking_zone)\n    .is(\"occupant_car\", null)\n    // .order(\"spot_id\", { ascending: true })\n    // .limit(1);\n\n  if (!spots || spots.length <= 0 || spot_error) {\n    statMsg = \"주차공간이 없습니다.\"\n    throw new Error(\"주차 공간이 없습니다\");\n  }\n\n  \n  const targetID = spots[Math.floor(Math.random() * spots.length)].spot_id;\n\n  // const targetID = spots[0].spot_id; \n\n  \n//parking_spots 테이블에 저장 parking_spots테이블은 화면을 구성하는 테이블 입니다.\n  const { error: parking_spots_error } = await supabase\n    .from(\"parking_spots\")\n    .update({ occupant_car: carNum, is_occupied: true })\n    .eq(\"spot_id\", targetID);\n  if (parking_spots_error) throw new Error(parking_spots_error);\n\n\n//parking_reservations 테이블을 이용해서 정산기능 구현했습니다.\n//16번 아이디가 삭제되면 안됩니다.\n  const { error: parking_reservations_error } = await supabase.from(\"parking_reservations\").insert([\n        {\n            profile_id: 2,\n            car_num: carNum,\n            visit_type: \"VISIT\",\n            start_date: new Date().toISOString(),\n            end_date: new Date().toISOString(),\n        },\n    ]);\n  if (parking_reservations_error) throw new Error(parking_reservations_error.message);\n\n  \n  return {targetID,statMsg};\n\n};\n\n\n\n\n//출차 처리\nexport const exitParking = async (carNum) => {\n  //1. 차량찾기\n  const { data: spot } = await supabase\n    .from(\"parking_spots\")\n    .select(\"*\")\n    .eq(\"occupant_car\", carNum)\n    .single(); //한개만 가져와라\n  if (!spot) throw new Error(\"주차장에 차가 없습니다\"); \n\n  const { data: reservations } = await supabase\n    .from(\"parking_reservations\")\n    .select(\"*\")\n    .eq(\"car_num\",carNum)\n    .eq(\"profile_id\",2)\n    .single(); //한개만 가져와라\n\n\n  let registerTime = null;\n\n  if (spot.zone === \"APT\") {\n    //이미 등록되어서 정산하지 않고 출차\n    console.log(\"주차타입 :\"+spot.zone);\n    registerTime = 0;\n  } else {\n    //2. 주차한 차를 찾으면, 주차 시간을 계산하기\n    const nowTime = new Date();\n    console.log(\"현재시간 :\"+nowTime);\n    const entryTime = new Date(reservations.start_date); //DB String --> Object // 현재시간 - 입차시간\n    console.log(\"입차시간 :\"+entryTime);\n    const diff = nowTime.getTime() - entryTime.getTime();\n    console.log(\"현재시간 - 입차시간 :\"+diff);\n    //시간주차를 했는지. 1초 이상 1시간\n    // registerTime = Math.round(diff / (1000 * 60 * 60 * 9));\n    registerTime = Math.round(diff / (60000));\n    console.log(\"최종시간 :\"+registerTime+\"분\");\n\n  }\n  return { registerTime: registerTime, spot_id: spot.spot_id , spot_type :spot.zone ,need_settlement: reservations.need_settlement};\n};\n\n\n\n\n\n//출차 확정\nexport const confirmExit = async (spotId,carNum) => {\n  const { error:parking_spots } = await supabase\n    .from(\"parking_spots\")\n    .update({ occupant_car: null, updated_at: null, is_occupied: false })\n    .eq(\"spot_id\", spotId);\n  if (parking_spots) throw new Error(\"출차하지 못했습니다\");\n\n  const { error: parking_reservations_error } = await supabase\n    .from(\"parking_reservations\")\n    .delete()\n    .eq(\"car_num\",carNum)\n    .eq(\"profile_id\",2);\n\n  if (parking_reservations_error) throw new Error(parking_reservations_error);\n};\n\n\nexport const adjustment = async (carNum) => {\n  const { data: settlement, error } = await supabase\n    .from(\"parking_reservations\")\n    .select(\"*\")\n    .eq(\"car_num\", carNum)\n    .eq(\"profile_id\",2)\n    .maybeSingle();\n  if (error) throw error;\n\n  return {settlement: settlement.need_settlement, sdata : settlement.start_date};\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}